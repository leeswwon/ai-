<!-- Chosen Palette: Minimalist Wordle (Green: #538d4e, Yellow: #b59f3b, Gray: #86888a on a light gray background #f9fafb) -->
<!-- Application Structure Plan: A single-screen game interface designed for clarity and focus. The structure includes a header, a central 6x5 game grid, a message area, a hidden input field for physical keyboard entry, and a dynamic on-screen virtual keyboard with a proper Hangul composition engine for touch/mouse input and hints. A modal dialog is used for final results. This structure provides multiple input methods and rich visual feedback, enhancing usability. -->
<!-- Visualization & Content Choices: The primary "visualization" is the game grid and the virtual keyboard. Report Info: User's report of Hangul composition bug -> Goal: Implement a robust and correct Hangul IME for the virtual keyboard -> Presentation Method: A dynamic grid of buttons (HTML/CSS/JS) at the bottom of the screen. -> Interaction: Clicking keys now correctly composes Hangul syllables in the current tile, including complex vowels and consonants. After a guess, key colors update to reflect their status. -> Justification: A functional virtual keyboard is essential for mobile usability and provides an excellent, persistent visual reference for letter statuses, improving the gameplay loop. Library/Method: Vanilla JS and CSS transitions. -->
<!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì˜¤ëŠ˜ì˜ ë‹¨ì–´ ê²Œì„</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: manipulation;
            background-color: #f9fafb;
        }
        .tile {
            width: 62px;
            height: 62px;
            font-size: 2rem;
            line-height: 1;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            border: 2px solid #e5e7eb;
            font-weight: bold;
            transition: transform 0.6s, background-color 0.3s, border-color 0.3s;
            transform-style: preserve-3d;
        }
        .tile.filled {
            border-color: #d1d5db;
        }
        .tile.flip {
            transform: rotateX(180deg);
        }
        .tile.correct, .key-correct {
            background-color: #538d4e !important;
            border-color: #538d4e !important;
            color: white !important;
        }
        .tile.present, .key-present {
            background-color: #b59f3b !important;
            border-color: #b59f3b !important;
            color: white !important;
        }
        .tile.absent, .key-absent {
            background-color: #86888a !important;
            border-color: #86888a !important;
            color: white !important;
        }
        #hidden-input {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            width: 0;
            height: 0;
        }
        .keyboard-key {
            height: 58px;
        }
        @media (max-width: 380px) {
            .tile {
                width: 52px;
                height: 52px;
                font-size: 1.75rem;
            }
            .keyboard-key {
                height: 50px;
                padding: 0;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body class="flex flex-col h-screen p-2 sm:p-4">

    <header class="w-full max-w-md text-center py-4 relative mx-auto">
        <h1 class="text-3xl font-bold tracking-tighter text-gray-800">ì˜¤ëŠ˜ì˜ ë‹¨ì–´</h1>
        <button id="help-button" class="absolute top-1/2 right-0 -translate-y-1/2 text-sm font-semibold text-gray-500 hover:text-gray-800 border border-gray-300 hover:border-gray-400 px-3 py-1.5 rounded-lg transition-colors">ê²Œì„ë°©ë²• í™•ì¸</button>
    </header>

    <main id="game-container" class="flex flex-col items-center justify-center flex-grow w-full max-w-md mx-auto">
        <div id="message-container" class="h-8 text-center font-medium text-gray-700 mb-4"></div>
        <div id="grid-container" class="grid grid-rows-6 gap-1.5 mb-4">
        </div>
    </main>
    
    <div id="keyboard" class="w-full max-w-lg mx-auto mt-auto"></div>
    <input type="text" id="hidden-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
    
    <div id="result-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-lg p-8 max-w-sm w-full text-center">
            <h2 id="result-title" class="text-2xl font-bold mb-4"></h2>
            <p class="mb-2 text-gray-700">ì •ë‹µì€ <strong id="correct-answer" class="text-xl text-black"></strong> ì´ì—ˆìŠµë‹ˆë‹¤.</p>
            <p id="result-message" class="mb-6"></p>
            <button id="play-again" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg transition-colors">ìƒˆ ê²Œì„ ì‹œì‘</button>
        </div>
    </div>

    <div id="instructions-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-lg p-6 max-w-md w-full relative">
            <button id="close-instructions" class="absolute top-2 right-2 text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
            <h2 class="text-2xl font-bold mb-4 text-center">ê²Œì„ ë°©ë²•</h2>
            <div class="text-left space-y-4">
                <p><strong>ëª©í‘œ:</strong> ì—¬ì„¯ ë²ˆì˜ ê¸°íšŒ ì•ˆì— ë‹¤ì„¯ ê¸€ìë¡œ ëœ ì˜¤ëŠ˜ì˜ ë¹„ë°€ ë‹¨ì–´ë¥¼ ë§í˜€ë³´ì„¸ìš”!</p>
                <div>
                    <h3 class="font-semibold text-lg mb-2">ê²Œì„ ë°©ë²•</h3>
                    <ol class="list-decimal list-inside space-y-1">
                        <li>í™”ë©´ì˜ í‚¤ë³´ë“œë‚˜ ê¸°ê¸°ì˜ í‚¤ë³´ë“œë¥¼ ì‚¬ìš©í•´ ë‹¨ì–´ë¥¼ ì…ë ¥í•©ë‹ˆë‹¤.</li>
                        <li><code>Enter</code> í‚¤ë¥¼ ëˆŒëŸ¬ ì…ë ¥í•œ ë‹¨ì–´ë¥¼ ì œì¶œí•©ë‹ˆë‹¤.</li>
                        <li>íƒ€ì¼ì˜ ìƒ‰ê¹” íŒíŠ¸ë¥¼ ë³´ê³  ë‹¤ìŒ ë‹¨ì–´ë¥¼ ì¶”ë¦¬í•©ë‹ˆë‹¤.</li>
                    </ol>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-2">íŒíŠ¸ ìƒ‰ê¹”ì˜ ì˜ë¯¸</h3>
                    <div class="space-y-3">
                        <div class="flex items-center">
                            <div class="tile correct w-12 h-12 text-lg mr-3 flex-shrink-0">ì •</div>
                            <div><strong class="text-green-600">ì´ˆë¡ìƒ‰:</strong> ì •í™•! ê¸€ìì™€ ìœ„ì¹˜ê°€ ëª¨ë‘ ë§ìŠµë‹ˆë‹¤.</div>
                        </div>
                         <div class="flex items-center">
                            <div class="tile present w-12 h-12 text-lg mr-3 flex-shrink-0">í¬</div>
                            <div><strong class="text-yellow-600">ë…¸ë€ìƒ‰:</strong> í¬í•¨! ë‹¨ì–´ì— í¬í•¨ëì§€ë§Œ, ìœ„ì¹˜ê°€ ë‹¤ë¦…ë‹ˆë‹¤.</div>
                        </div>
                         <div class="flex items-center">
                            <div class="tile absent w-12 h-12 text-lg mr-3 flex-shrink-0">ì—†</div>
                            <div><strong class="text-gray-500">íšŒìƒ‰:</strong> ì—†ìŒ! ë‹¨ì–´ì— í¬í•¨ë˜ì§€ ì•Šì€ ê¸€ìì…ë‹ˆë‹¤.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gridContainer = document.getElementById('grid-container');
            const messageContainer = document.getElementById('message-container');
            const hiddenInput = document.getElementById('hidden-input');
            const keyboardContainer = document.getElementById('keyboard');
            const resultModal = document.getElementById('result-modal');
            const resultTitle = document.getElementById('result-title');
            const correctAnswerEl = document.getElementById('correct-answer');
            const resultMessage = document.getElementById('result-message');
            const playAgainBtn = document.getElementById('play-again');
            const helpButton = document.getElementById('help-button');
            const instructionsModal = document.getElementById('instructions-modal');
            const closeInstructionsBtn = document.getElementById('close-instructions');

            const wordList = ["í¬ë¦¬ìŠ¤ë§ˆìŠ¤", "ë°”ë‚˜ë‚˜ìš°ìœ ", "ì•„ì´ìŠ¤í¬ë¦¼", "ì˜¤ë Œì§€ì£¼ìŠ¤", "ê°€ë‚˜ì´ˆì½œë¦¿", "ì—ìŠ¤í”„ë ˆì†Œ", "ì•„ë©”ë¦¬ì¹´ë…¸", "í”„ë¡œê·¸ë˜ë¨¸", "ì•ˆë…•í•˜ì„¸ìš”", "ë°˜ê°‘ìŠµë‹ˆë‹¤", "í•´ë°”ë¼ê¸°ì”¨", "ê³ êµ¬ë§ˆë¼ë–¼", "í”„ë¡ íŠ¸ì—”ë“œ", "ì•ˆë“œë¡œì´ë“œ", "ê°€ë‚˜ë‹¤ë¼ë§ˆ"];
            let secretWord = '';
            
            const Hangul = {
                CHO: ['ã„±', 'ã„²', 'ã„´', 'ã„·', 'ã„¸', 'ã„¹', 'ã…', 'ã…‚', 'ã…ƒ', 'ã……', 'ã…†', 'ã…‡', 'ã…ˆ', 'ã…‰', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'],
                JUNG: ['ã…', 'ã…', 'ã…‘', 'ã…’', 'ã…“', 'ã…”', 'ã…•', 'ã…–', 'ã…—', 'ã…˜', 'ã…™', 'ã…š', 'ã…›', 'ã…œ', 'ã…', 'ã…', 'ã…Ÿ', 'ã… ', 'ã…¡', 'ã…¢', 'ã…£'],
                JONG: ['', 'ã„±', 'ã„²', 'ã„³', 'ã„´', 'ã„µ', 'ã„¶', 'ã„·', 'ã„¹', 'ã„º', 'ã„»', 'ã„¼', 'ã„½', 'ã„¾', 'ã„¿', 'ã…€', 'ã…', 'ã…‚', 'ã…„', 'ã……', 'ã…†', 'ã…‡', 'ã…ˆ', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'],
                COMPLEX_VOWELS: { 'ã…—ã…': 'ã…˜', 'ã…—ã…': 'ã…™', 'ã…—ã…£': 'ã…š', 'ã…œã…“': 'ã…', 'ã…œã…”': 'ã…', 'ã…œã…£': 'ã…Ÿ', 'ã…¡ã…£': 'ã…¢' },
                COMPLEX_CONSONANTS: { 'ã„±ã……': 'ã„³', 'ã„´ã…ˆ': 'ã„µ', 'ã„´ã…': 'ã„¶', 'ã„¹ã„±': 'ã„º', 'ã„¹ã…': 'ã„»', 'ã„¹ã…‚': 'ã„¼', 'ã„¹ã……': 'ã„½', 'ã„¹ã…Œ': 'ã„¾', 'ã„¹ã…': 'ã„¿', 'ã„¹ã…': 'ã…€', 'ã…‚ã……': 'ã…„' },
                isVowel: (char) => Hangul.JUNG.includes(char),
                isConsonant: (char) => Hangul.CHO.includes(char),
                compose: (cho, jung, jong) => String.fromCharCode(0xAC00 + (Hangul.CHO.indexOf(cho) * 588) + (Hangul.JUNG.indexOf(jung) * 28) + Hangul.JONG.indexOf(jong || '')),
                decompose: (syllable) => {
                    if (!syllable || !syllable.match(/[ê°€-í£]/)) return [syllable];
                    const code = syllable.charCodeAt(0) - 0xAC00;
                    const jongIdx = code % 28;
                    const jungIdx = ((code - jongIdx) / 28) % 21;
                    const choIdx = Math.floor(code / 588);
                    return [Hangul.CHO[choIdx], Hangul.JUNG[jungIdx], jongIdx > 0 ? Hangul.JONG[jongIdx] : null].filter(Boolean);
                }
            };

            const state = {
                currentRow: 0,
                currentCol: 0,
                isGameOver: false,
                isComposing: false,
                composition: { cho: null, jung: null, jong: null }
            };

            function getTile(row, col) { return document.getElementById(`tile-${row}-${col}`); }
            function getGuess() {
                const guess = [];
                for (let i = 0; i < 5; i++) { guess.push(getTile(state.currentRow, i).textContent); }
                return guess;
            }

            function initializeGame() {
                state.currentRow = 0;
                state.currentCol = 0;
                state.isGameOver = false;
                state.isComposing = false;
                
                const today = new Date();
                const dayIndex = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24));
                secretWord = wordList[dayIndex % wordList.length];
                
                createGrid();
                createKeyboard();
                resultModal.classList.add('hidden');
                instructionsModal.classList.add('hidden');
                messageContainer.textContent = '';
                hiddenInput.value = '';
                hiddenInput.focus();
                resetComposition();
            }

            function createGrid() {
                gridContainer.innerHTML = '';
                for (let i = 0; i < 6; i++) {
                    const row = document.createElement('div');
                    row.className = 'grid grid-cols-5 gap-1.5';
                    for (let j = 0; j < 5; j++) {
                        const tile = document.createElement('div');
                        tile.className = 'tile';
                        tile.id = `tile-${i}-${j}`;
                        row.appendChild(tile);
                    }
                    gridContainer.appendChild(row);
                }
            }

            function createKeyboard() {
                keyboardContainer.innerHTML = '';
                const keys = [
                    ['ã…‚', 'ã…ˆ', 'ã„·', 'ã„±', 'ã……', 'ã…›', 'ã…•', 'ã…‘', 'ã…', 'ã…”'],
                    ['ã…', 'ã„´', 'ã…‡', 'ã„¹', 'ã…', 'ã…—', 'ã…“', 'ã…', 'ã…£'],
                    ['ENTER', 'ã…‹', 'ã…Œ', 'ã…Š', 'ã…', 'ã… ', 'ã…œ', 'ã…¡', 'âŒ«'],
                    ['Shift', 'ã„²', 'ã„¸', 'ã…ƒ', 'ã…†', 'ã…‰']
                ];
                
                keys.forEach((rowKeys) => {
                    const row = document.createElement('div');
                    row.className = 'flex w-full gap-1.5 my-1 justify-center';
                    rowKeys.forEach(key => {
                        const btn = document.createElement('button');
                        btn.className = 'keyboard-key flex-1 rounded font-semibold bg-gray-200 hover:bg-gray-300 transition-colors p-1';
                        btn.textContent = key;
                        btn.dataset.key = key;
                        if (key === 'ENTER' || key === 'âŒ«' || key === 'Shift') btn.style.flex = '1.5';
                        btn.addEventListener('click', () => handleKeyPress(key));
                        row.appendChild(btn);
                    });
                    keyboardContainer.appendChild(row);
                });
            }
            
            function resetComposition() { state.composition = { cho: null, jung: null, jong: null }; }
            
            function updateCurrentTile() {
                const tile = getTile(state.currentRow, state.currentCol);
                if (!tile) return;
                const { cho, jung, jong } = state.composition;
                
                if (cho !== null) {
                    if (jung !== null) {
                        tile.textContent = Hangul.compose(cho, jung, jong);
                    } else {
                        tile.textContent = cho;
                    }
                } else {
                    tile.textContent = '';
                }

                if(tile.textContent) tile.classList.add('filled');
                else tile.classList.remove('filled');
            }
            
            function handleKeyPress(key) {
                if(state.isGameOver) return;
                
                const shiftMap = {'ã…‚':'ã…ƒ', 'ã…ˆ':'ã…‰', 'ã„·':'ã„¸', 'ã„±':'ã„²', 'ã……':'ã…†', 'ã…':'ã…’', 'ã…”':'ã…–'};
                if(key === 'Shift') {
                    // This is a placeholder for shift functionality if needed later.
                    return;
                }
                 if(Object.values(shiftMap).includes(key)){
                     key = Object.keys(shiftMap).find(k => shiftMap[k] === key);
                 }


                if (key === 'ENTER') submitGuess();
                else if (key === 'âŒ«') deleteLetter();
                else typeLetter(key);
            }

            function typeLetter(key) {
                const { cho, jung, jong } = state.composition;
                
                if (Hangul.isConsonant(key)) {
                    if (cho === null) { // ì´ˆì„± ì…ë ¥
                        if (state.currentCol >= 5) return;
                        state.composition.cho = key;
                    } else if (jung === null) { // ì´ˆì„±ë§Œ ìˆëŠ” ìƒíƒœ (e.g. 'ã„±')
                        moveToNextTile(key);
                    } else if (jong === null) { // ì´ˆì„±+ì¤‘ì„± (e.g. 'ê°€')
                        if (Hangul.JONG.includes(key)) {
                            state.composition.jong = key;
                        } else {
                            moveToNextTile(key);
                        }
                    } else { // ì´ˆì„±+ì¤‘ì„±+ì¢…ì„± (e.g. 'ê°')
                        const combined = jong + key;
                        const combinedKey = Object.keys(Hangul.COMPLEX_CONSONANTS).find(k => k === combined);
                        if (combinedKey) {
                            state.composition.jong = Hangul.COMPLEX_CONSONANTS[combinedKey];
                        } else {
                            moveToNextTile(key);
                        }
                    }
                } else if (Hangul.isVowel(key)) {
                    if (cho === null) { // ë¹ˆ ì¹¸
                         // Vowels can't start a syllable on their own
                    } else if (jung === null) { // ì´ˆì„±ë§Œ ìˆì„ ë•Œ
                        state.composition.jung = key;
                    } else if (jong === null) { // ì´ˆì„±+ì¤‘ì„±
                        const combined = jung + key;
                        const combinedKey = Object.keys(Hangul.COMPLEX_VOWELS).find(k => k === combined);
                        if(combinedKey) {
                            state.composition.jung = Hangul.COMPLEX_VOWELS[combinedKey];
                        } else {
                             moveToNextTile();
                        }
                    } else { // ì´ˆì„±+ì¤‘ì„±+ì¢…ì„±
                        const jongParts = Object.keys(Hangul.COMPLEX_CONSONANTS).find(k => Hangul.COMPLEX_CONSONANTS[k] === jong) || jong;
                        const firstJong = jongParts[0];
                        const secondJong = jongParts.length > 1 ? jongParts[1] : null;

                        state.composition.jong = firstJong;
                        updateCurrentTile();
                        
                        moveToNextTile(null);

                        if (state.currentCol < 5) {
                            state.composition.cho = secondJong || firstJong;
                            state.composition.jung = key;
                        }
                    }
                }
                updateCurrentTile();
            }
            
            function moveToNextTile(nextKey = null) {
                const tile = getTile(state.currentRow, state.currentCol);
                if (tile && tile.textContent) {
                    if (state.currentCol < 4) {
                        state.currentCol++;
                        resetComposition();
                        if (nextKey) state.composition.cho = nextKey;
                    } else if (state.currentCol === 4) {
                        state.currentCol = 5;
                        resetComposition();
                    }
                }
            }

            function deleteLetter() {
                const { cho, jung, jong } = state.composition;

                if (jong !== null) {
                    const jongKey = Object.keys(Hangul.COMPLEX_CONSONANTS).find(k => Hangul.COMPLEX_CONSONANTS[k] === jong);
                    if(jongKey) state.composition.jong = jongKey[0];
                    else state.composition.jong = null;
                } else if (jung !== null) {
                     const jungKey = Object.keys(Hangul.COMPLEX_VOWELS).find(k => Hangul.COMPLEX_VOWELS[k] === jung);
                     if (jungKey) state.composition.jung = jungKey[0];
                     else state.composition.jung = null;
                } else if (cho !== null) {
                    state.composition.cho = null;
                    if(state.currentCol > 0) {
                        state.currentCol--;
                        const prevSyllable = getTile(state.currentRow, state.currentCol).textContent;
                        const parts = Hangul.decompose(prevSyllable);
                        state.composition.cho = parts[0] || null;
                        state.composition.jung = parts[1] || null;
                        state.composition.jong = parts[2] || null;
                    }
                }
                updateCurrentTile();
            }


            function submitGuess() {
                if (state.isGameOver) return;
                const currentGuess = getGuess();
                if (currentGuess.some(char => char === '')) {
                    showMessage('5ê¸€ìë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                    return;
                }
                revealGuess(evaluateGuess(currentGuess.join('')));
            }

            function evaluateGuess(guess) {
                 const remainingLetters = secretWord.split('');
                const guessResult = Array(5).fill(null);
                for (let i = 0; i < 5; i++) {
                    if (guess[i] === secretWord[i]) {
                        guessResult[i] = 'correct';
                        remainingLetters[i] = null;
                    }
                }
                for (let i = 0; i < 5; i++) {
                    if (guessResult[i] === null && remainingLetters.includes(guess[i])) {
                        guessResult[i] = 'present';
                        remainingLetters[remainingLetters.indexOf(guess[i])] = null;
                    }
                }
                for (let i = 0; i < 5; i++) {
                    if (guessResult[i] === null) guessResult[i] = 'absent';
                }
                return guessResult;
            }

            function revealGuess(result) {
                const rowTiles = gridContainer.children[state.currentRow].children;
                const guess = getGuess();
                state.isGameOver = true; 
                result.forEach((status, i) => {
                    setTimeout(() => {
                        const tile = rowTiles[i];
                        tile.classList.add('flip');
                        setTimeout(() => {
                            tile.classList.add(status);
                            updateKeyboard(guess[i], status);
                        }, 250);
                    }, i * 400);
                });
                setTimeout(() => checkGameOver(result), 5 * 400);
            }
            
            function updateKeyboard(letter, status) {
                const parts = Hangul.decompose(letter);
                parts.forEach(part => {
                    const subParts = Object.values(Hangul.COMPLEX_CONSONANTS).find(v => v === part) || Object.values(Hangul.COMPLEX_VOWELS).find(v => v === part) || [part];
                    subParts.forEach(p => updateKey(p, status));
                });
            }
            
            function updateKey(keyChar, status){
                 const key = keyboardContainer.querySelector(`[data-key="${keyChar}"]`);
                 if (key) {
                    const currentStatus = key.dataset.status;
                    if (currentStatus === 'correct') return;
                    if (currentStatus === 'present' && status === 'absent') return;
                    key.classList.remove('key-present', 'key-absent');
                    key.classList.add(`key-${status}`);
                    key.dataset.status = status;
                 }
            }

            function checkGameOver(result) {
                if (result.every(s => s === 'correct')) {
                    endGame(true);
                } else if (state.currentRow < 5) {
                    state.currentRow++;
                    state.currentCol = 0;
                    state.isGameOver = false;
                    resetComposition();
                    hiddenInput.focus();
                } else {
                    endGame(false);
                }
            }

            function endGame(isWin) {
                state.isGameOver = true;
                setTimeout(() => {
                    resultModal.classList.remove('hidden');
                    correctAnswerEl.textContent = secretWord;
                    if (isWin) {
                        resultTitle.textContent = "ğŸ‰ ì„±ê³µ! ğŸ‰";
                        resultMessage.textContent = `${state.currentRow + 1}ë²ˆ ë§Œì— ë§íˆì…¨ë„¤ìš”!`;
                    } else {
                        resultTitle.textContent = "ğŸ˜­ ì•„ì‰½ë„¤ìš” ğŸ˜­";
                        resultMessage.textContent = "ë‹¤ìŒ ê¸°íšŒì— ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”.";
                    }
                }, 500);
            }
            
            function showMessage(msg) {
                messageContainer.textContent = msg;
                setTimeout(() => { messageContainer.textContent = ''; }, 2000);
            }

            document.body.addEventListener('click', () => { if (!state.isGameOver) hiddenInput.focus(); });
            
            hiddenInput.addEventListener('compositionstart', () => { state.isComposing = true; });
            hiddenInput.addEventListener('compositionend', (e) => {
                state.isComposing = false;
                const typedText = e.data;
                if (state.isGameOver || !typedText) return;

                for (const char of typedText) {
                    if (char.match(/^[ê°€-í£]$/)) {
                       if (state.currentCol < 5) {
                           getTile(state.currentRow, state.currentCol).textContent = char;
                           moveToNextTile();
                       }
                    }
                }
                hiddenInput.value = '';
            });

            document.addEventListener('keydown', (e) => {
                if (state.isComposing) return;
                const keyMap = {'Backspace': 'âŒ«', 'Enter': 'ENTER'};
                const shiftedKeyMap = {'ã…‚':'ã…ƒ', 'ã…ˆ':'ã…‰', 'ã„·':'ã„¸', 'ã„±':'ã„²', 'ã……':'ã…†', 'ã…':'ã…’', 'ã…”':'ã…–'};

                let key = e.key;
                if(e.shiftKey && shiftedKeyMap[key]){
                    key = shiftedKeyMap[key];
                }
                
                handleKeyPress(keyMap[key] || key);
            });
            
            playAgainBtn.addEventListener('click', initializeGame);
            helpButton.addEventListener('click', () => { instructionsModal.classList.remove('hidden'); });
            closeInstructionsBtn.addEventListener('click', () => { instructionsModal.classList.add('hidden'); });
            instructionsModal.addEventListener('click', (e) => {
                if (e.target === instructionsModal) instructionsModal.classList.add('hidden');
            });

            initializeGame();
        });
    </script>
</body>
</html>
